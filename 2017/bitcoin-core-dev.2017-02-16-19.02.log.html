<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<title>#bitcoin-core-dev log</title>
<style type="text/css">
/* For the .log.html */
pre { /*line-height: 125%;*/
      white-space: pre-wrap; }
body { background: #f0f0f0; }

body .tm  { color: #007020 }                      /* time */
body .nk  { color: #062873; font-weight: bold }   /* nick, regular */
body .nka { color: #007020; font-weight: bold }  /* action nick */
body .ac  { color: #00A000 }                      /* action line */
body .hi  { color: #4070a0 }                 /* hilights */
/* Things to make particular MeetBot commands stick out */
body .topic     { color: #007020; font-weight: bold }
body .topicline { color: #000080; font-weight: bold }
body .cmd       { color: #007020; font-weight: bold }
body .cmdline  { font-weight: bold }

</style>
</head>

<body>
<pre><a name="l-1"></a><span class="tm">19:02:37</span><span class="nk"> &lt;wumpus&gt;</span> <span class="cmd">#startmeeting</span><span class="cmdline"></span>
<a name="l-2"></a><span class="tm">19:02:37</span><span class="nk"> &lt;lightningbot&gt;</span> Meeting started Thu Feb 16 19:02:37 2017 UTC.  The chair is wumpus. Information about MeetBot at http://wiki.debian.org/MeetBot.
<a name="l-3"></a><span class="tm">19:02:37</span><span class="nk"> &lt;lightningbot&gt;</span> Useful Commands: #action #agreed #help #info #idea #link #topic.
<a name="l-4"></a><span class="tm">19:02:58</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">jonasschnelli:</span> well it's a magic option value but it's only for the option, it doesn't get represented internally as 1
<a name="l-5"></a><span class="tm">19:03:01</span><span class="nk"> &lt;luke-jr&gt;</span> tbh, I've had second thoughts about the manual pruning design (seems it'd be nicer to do "automatic pruning always, but with named barriers that must confirm being done up to &lt;height&gt; before pruning it"), but that's beyond this topic
<a name="l-6"></a><span class="tm">19:03:18</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">jonasschnelli:</span> I think the reason or choosing 1 was that -prune will work
<a name="l-7"></a><span class="tm">19:03:27</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">luke-jr:</span> I like the current manual pruning from an API point of view
<a name="l-8"></a><span class="tm">19:03:28</span><span class="nk"> &lt;luke-jr&gt;</span> s/always/always in pruning mode/
<a name="l-9"></a><span class="tm">19:03:33</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="cmd">#bitcoin-core-dev </span><span class="cmdline">Meeting: wumpus sipa gmaxwell jonasschnelli morcos luke-jr btcdrak sdaftuar jtimon cfields petertodd kanzure bluematt instagibbs phantomcircuit codeshark michagogo marcofalke paveljanik NicolasDorier</span>
<a name="l-10"></a><span class="tm">19:03:44</span><span class="nk"> &lt;luke-jr&gt;</span> <span class="hi">wumpus:</span> yes, but it doesn't scale well if you have 2 external apps using the node
<a name="l-11"></a><span class="tm">19:04:02</span><span class="nk"> &lt;cfields&gt;</span> hi
<a name="l-12"></a><span class="tm">19:04:05</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">luke-jr:</span> it's very simple. Automatic pruning is disabled and the client/admin can choose what to prune. Also useful for testing the pruning stuff without too much complexity
<a name="l-13"></a><span class="tm">19:04:12</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">luke-jr:</span> the implementation is convoluted though
<a name="l-14"></a><span class="tm">19:04:16</span><span class="nk"> &lt;morcos&gt;</span> <span class="hi">wumpus:</span> i think two more are needed for 0.14, both very small  #9760 and #9761  (9761 is already included in one of the marked ones)
<a name="l-15"></a><span class="tm">19:04:17</span><span class="nk"> &lt;gribble&gt;</span> https://github.com/bitcoin/bitcoin/issues/9760 | [wallet] Remove importmulti always-true check by ryanofsky Â· Pull Request #9760 Â· bitcoin/bitcoin Â· GitHub
<a name="l-16"></a><span class="tm">19:04:18</span><span class="nk"> &lt;paveljanik&gt;</span> proposed topic: release status, where can we help...
<a name="l-17"></a><span class="tm">19:04:19</span><span class="nk"> &lt;gribble&gt;</span> https://github.com/bitcoin/bitcoin/issues/9761 | Use 2 hour grace period for key timestamps in importmulti rescans by ryanofsky Â· Pull Request #9761 Â· bitcoin/bitcoin Â· GitHub
<a name="l-18"></a><span class="tm">19:04:22</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">luke-jr:</span> but I'm happy someone implemented it anyhow
<a name="l-19"></a><span class="tm">19:04:27 </span><span class="nka">* luke-jr</span> <span class="ac">nods</span>
<a name="l-20"></a><span class="tm">19:04:41</span><span class="nk"> &lt;kanzure&gt;</span> hi.
<a name="l-21"></a><span class="tm">19:04:47</span><span class="nk"> &lt;petertodd&gt;</span> <span class="hi">wumpus:</span> same: my OpenTimestamps servers actually need this feature
<a name="l-22"></a><span class="tm">19:04:58</span><span class="nk"> &lt;wumpus&gt;</span> release status: running as hard as we can but staying in the same place
<a name="l-23"></a><span class="tm">19:05:09</span><span class="nk"> &lt;sipa&gt;</span> i think we're very close.
<a name="l-24"></a><span class="tm">19:05:13</span><span class="nk"> &lt;morcos&gt;</span> <span class="hi">wumpus:</span> boo!  we're not staying in the same place
<a name="l-25"></a><span class="tm">19:05:19</span><span class="nk"> &lt;gmaxwell&gt;</span> I am becoming increasingly happy with the release.
<a name="l-26"></a><span class="tm">19:05:29</span><span class="nk"> &lt;sipa&gt;</span> let's be optimistic: everything we're fixing is an improvememt
<a name="l-27"></a><span class="tm">19:05:51</span><span class="nk"> &lt;gmaxwell&gt;</span> Two weeks ago I was chewing my nails feeling like we were at risk of shipping something that wouldn't meet our standards of quality, and now I am not worried. :)
<a name="l-28"></a><span class="tm">19:06:05</span><span class="nk"> &lt;jonasschnelli&gt;</span> hah. Good.
<a name="l-29"></a><span class="tm">19:06:06</span><span class="nk"> &lt;wumpus&gt;</span> but I think we need to decide when we can do release candidate 1, which is a test release anyway, when rc1 is out it's bound to find more issues
<a name="l-30"></a><span class="tm">19:06:32</span><span class="nk"> &lt;sipa&gt;</span> i think we can do rc1 today?
<a name="l-31"></a><span class="tm">19:06:52</span><span class="nk"> &lt;gmaxwell&gt;</span> I would be fine doing it _now_, now.  There are AFAIK not anything in the pipe which are disruptive enough issues that they'd degrade our rc1 learning, though a rc2 will be guarenteed.
<a name="l-32"></a><span class="tm">19:06:53</span><span class="nk"> &lt;paveljanik&gt;</span> rc1 for the weekend is fine!
<a name="l-33"></a><span class="tm">19:06:56</span><span class="nk"> &lt;sipa&gt;</span> or at least branch off today
<a name="l-34"></a><span class="tm">19:06:59</span><span class="nk"> &lt;luke-jr&gt;</span> I don't think we have any critical problems blocking a rc1
<a name="l-35"></a><span class="tm">19:07:17</span><span class="nk"> &lt;jtimon&gt;</span> <span class="hi">sipa:</span> why branch of if we can't rc1 ?
<a name="l-36"></a><span class="tm">19:07:19</span><span class="nk"> &lt;wumpus&gt;</span> I don't think so either
<a name="l-37"></a><span class="tm">19:07:24</span><span class="nk"> &lt;cfields&gt;</span> no more blockers from me either
<a name="l-38"></a><span class="tm">19:07:26</span><span class="nk"> &lt;luke-jr&gt;</span> <span class="hi">jtimon:</span> to begin merging for 0.15?
<a name="l-39"></a><span class="tm">19:07:40</span><span class="nk"> &lt;wumpus&gt;</span> right, because more and more pulls for 0.15 are waiting
<a name="l-40"></a><span class="tm">19:07:40 </span><span class="nka">* jtimon</span> <span class="ac">nods</span>
<a name="l-41"></a><span class="tm">19:07:58</span><span class="nk"> &lt;jonasschnelli&gt;</span> IMO the two import multi fixes are not critical and can go in after rc1 (or even in 0.15 in the worst case).
<a name="l-42"></a><span class="tm">19:08:08</span><span class="nk"> &lt;gmaxwell&gt;</span> all you naughty people not banging away at getting 0.14 ready to go.
<a name="l-43"></a><span class="tm">19:08:29</span><span class="nk"> &lt;morcos&gt;</span> <span class="hi">jonasschnelli:</span> well lets decide that
<a name="l-44"></a><span class="tm">19:08:40</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">jonasschnelli:</span> I think 0.15 would be really unfortunate since they're interface changes that users may have to accomidate in their software. (and also are covering corner cases that could result in funds losses)
<a name="l-45"></a><span class="tm">19:08:42</span><span class="nk"> &lt;wumpus&gt;</span> I think the fixes are all important, and should get either into 0.14.0 or backported to the 0.14 branch if they don't, but not everything should be regarded as yet another thing to hold up rc1
<a name="l-46"></a><span class="tm">19:08:43</span><span class="nk"> &lt;morcos&gt;</span> yesterday people were saying it was bad to release with something that coudl silently not find funds
<a name="l-47"></a><span class="tm">19:09:03</span><span class="nk"> &lt;gmaxwell&gt;</span> but no reason to hold rc1 for them. They're well understood.
<a name="l-48"></a><span class="tm">19:09:28</span><span class="nk"> &lt;jonasschnelli&gt;</span> Yes. I think the should be in 0.14. Just worst case if we spun of rc1 and chaincode-labs colabses. :)
<a name="l-49"></a><span class="tm">19:09:29</span><span class="nk"> &lt;wumpus&gt;</span> anyhow tomorrow sounds good to me, let's try to get in what we can get in
<a name="l-50"></a><span class="tm">19:09:31</span><span class="nk"> &lt;gmaxwell&gt;</span> it's not like someone is going to encounter one of them running rc1 and leave us going "shit was that the know issue or something else?"
<a name="l-51"></a><span class="tm">19:09:32</span><span class="nk"> &lt;luke-jr&gt;</span> <span class="cmd">#9619 </span><span class="cmdline">is a fix, but not really critical since anyone affected needs a workaround in 0.13 anyway (just pushed an amend-with-no-changes because the Travis error seems impossible)</span>
<a name="l-52"></a><span class="tm">19:09:33</span><span class="nk"> &lt;gribble&gt;</span> https://github.com/bitcoin/bitcoin/issues/9619 | Bugfix: RPC/Mining: GBT should return 1 MB sizelimit before segwit activates by luke-jr Â· Pull Request #9619 Â· bitcoin/bitcoin Â· GitHub
<a name="l-53"></a><span class="tm">19:09:34</span><span class="nk"> &lt;achow101&gt;</span> what's the point of making an rc1 if we're going to need rc2 anyways?
<a name="l-54"></a><span class="tm">19:09:42</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">achow101:</span> exposure
<a name="l-55"></a><span class="tm">19:09:46</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">achow101:</span> to start getting people using it.
<a name="l-56"></a><span class="tm">19:09:50</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">achow101:</span> get the code actually tested?
<a name="l-57"></a><span class="tm">19:09:52</span><span class="nk"> &lt;gmaxwell&gt;</span> more*
<a name="l-58"></a><span class="tm">19:09:56</span><span class="nk"> &lt;wumpus&gt;</span> what is the point of doing rc1 at all if not?
<a name="l-59"></a><span class="tm">19:09:57</span><span class="nk"> &lt;kanzure&gt;</span> and seeking bug reports
<a name="l-60"></a><span class="tm">19:09:57</span><span class="nk"> &lt;jonasschnelli&gt;</span> I think we should plan enough time to fix stuff that gets report after rc1...
<a name="l-61"></a><span class="tm">19:10:18</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">jonasschnelli:</span> the release schedule already has 2 weeks left
<a name="l-62"></a><span class="tm">19:10:33</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">achow101:</span> I don't think it ever happened that a major release didn'tneed a rc2
<a name="l-63"></a><span class="tm">19:10:35</span><span class="nk"> &lt;luke-jr&gt;</span> 2 weeks can go fast
<a name="l-64"></a><span class="tm">19:10:52</span><span class="nk"> &lt;jonasschnelli&gt;</span> Other can work on fixes reported in rc1.
<a name="l-65"></a><span class="tm">19:10:54</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">achow101:</span> what we generally don't want to do is to ship an RC1 with issues bad enough that it will harm the testers seriously, or which will fail in mysterious ways that we can't learn from.  E.g. if we had a known crash fix, we would hold rc1, so that we wouldn't worry that every user crash report might have been an unknown issue.
<a name="l-66"></a><span class="tm">19:10:57</span><span class="nk"> &lt;jonasschnelli&gt;</span> *Others
<a name="l-67"></a><span class="tm">19:11:05</span><span class="nk"> &lt;morcos&gt;</span> my only concern is that if we do rc1 everyone will be distracted with that and not this last few remaining PR's..  but i guess i don't really care either way
<a name="l-68"></a><span class="tm">19:11:08</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">wumpus:</span> just forget the bump to v0.14 again and thereby guarantee an rc2 :p
<a name="l-69"></a><span class="tm">19:11:38</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">cfields:</span> lol exactly
<a name="l-70"></a><span class="tm">19:11:39</span><span class="nk"> &lt;morcos&gt;</span> seems like if someone would just review those PR's we might be able to get them merged today
<a name="l-71"></a><span class="tm">19:11:41</span><span class="nk"> &lt;gmaxwell&gt;</span> well I think an RC2 is already guarenteed if we do an rc1 ASAP. But thats fine. Much better than not doing the rc1.
<a name="l-72"></a><span class="tm">19:11:49</span><span class="nk"> &lt;achow101&gt;</span> ok
<a name="l-73"></a><span class="tm">19:12:04</span><span class="nk"> &lt;wumpus&gt;</span> a RC2 is guaranteed in any case, not just if we do rc1 asap
<a name="l-74"></a><span class="tm">19:12:17</span><span class="nk"> &lt;wumpus&gt;</span> that's my point, we don't know of all the issues yet
<a name="l-75"></a><span class="tm">19:12:26</span><span class="nk"> &lt;morcos&gt;</span> almost all the complication is in new tests.. reviewing the code changes is pretty simple
<a name="l-76"></a><span class="tm">19:13:18</span><span class="nk"> &lt;wumpus&gt;</span> the only one I doubt about is #9773, at it is still WIP
<a name="l-77"></a><span class="tm">19:13:20</span><span class="nk"> &lt;gribble&gt;</span> https://github.com/bitcoin/bitcoin/issues/9773 | WIP: Return errors from importmulti if complete rescans are not successful (on top of #9761) by ryanofsky Â· Pull Request #9773 Â· bitcoin/bitcoin Â· GitHub
<a name="l-78"></a><span class="tm">19:13:44</span><span class="nk"> &lt;luke-jr&gt;</span> it's a new feature, so we could just say "don't use this without being aware of the risks"
<a name="l-79"></a><span class="tm">19:14:13</span><span class="nk"> &lt;paveljanik&gt;</span> mark it as experimental then?
<a name="l-80"></a><span class="tm">19:14:40</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">paveljanik:</span> meh, i think we're close enough to not do that
<a name="l-81"></a><span class="tm">19:15:15</span><span class="nk"> &lt;luke-jr&gt;</span> I mean in rc1 only
<a name="l-82"></a><span class="tm">19:15:26</span><span class="nk"> &lt;wumpus&gt;</span> well even with that change it can be marked as experimental
<a name="l-83"></a><span class="tm">19:15:34</span><span class="nk"> &lt;wumpus&gt;</span> it is new code afterall
<a name="l-84"></a><span class="tm">19:15:39</span><span class="nk"> &lt;gmaxwell&gt;</span> I'm not too worried about it in rc1.
<a name="l-85"></a><span class="tm">19:16:12</span><span class="nk"> &lt;wumpus&gt;</span> there are probably still problems with it that we haven't found, which will be found by people testing it
<a name="l-86"></a><span class="tm">19:16:33</span><span class="nk"> &lt;paveljanik&gt;</span> we can mark it as experimental in the release notes only...
<a name="l-87"></a><span class="tm">19:16:33</span><span class="nk"> &lt;wumpus&gt;</span> so yes, experimental makes sense. Though a new major release should be considered experimental entirely
<a name="l-88"></a><span class="tm">19:16:37</span><span class="nk"> &lt;gmaxwell&gt;</span> people running rcs are the least likely to lose funds due to a rescan limitation, and there won't be many of them.
<a name="l-89"></a><span class="tm">19:17:50</span><span class="nk"> &lt;morcos&gt;</span> i think it is a mistake to call it experimental
<a name="l-90"></a><span class="tm">19:17:56</span><span class="nk"> &lt;morcos&gt;</span> we don't want to devalue the meaning of that word
<a name="l-91"></a><span class="tm">19:18:13</span><span class="nk"> &lt;wumpus&gt;</span> ok...
<a name="l-92"></a><span class="tm">19:18:17</span><span class="nk"> &lt;morcos&gt;</span> sometimes we may want to have things that are actually experimental and we don't want people to think we just always say that
<a name="l-93"></a><span class="tm">19:18:40</span><span class="nk"> &lt;wumpus&gt;</span> "this feature is experimental level 4"
<a name="l-94"></a><span class="tm">19:18:44</span><span class="nk"> &lt;sipa&gt;</span> haha
<a name="l-95"></a><span class="tm">19:18:50</span><span class="nk"> &lt;kanzure&gt;</span> nasa technical readiness levels
<a name="l-96"></a><span class="tm">19:18:54</span><span class="nk"> &lt;CodeShark&gt;</span> The whole thing is experimental :p
<a name="l-97"></a><span class="tm">19:18:56</span><span class="nk"> &lt;morcos&gt;</span> this is known to the state of CA to be experimental
<a name="l-98"></a><span class="tm">19:18:56</span><span class="nk"> &lt;petertodd&gt;</span> <span class="hi">morcos:</span> "dangerously experimental"
<a name="l-99"></a><span class="tm">19:19:06</span><span class="nk"> &lt;petertodd&gt;</span> <span class="hi">morcos:</span> lol
<a name="l-100"></a><span class="tm">19:19:23</span><span class="nk"> &lt;gmaxwell&gt;</span> Yea, thats why I was not supporting expiremental.
<a name="l-101"></a><span class="tm">19:19:54</span><span class="nk"> &lt;instagibbs&gt;</span> morcos, accounts... deprecated!
<a name="l-102"></a><span class="tm">19:20:13</span><span class="nk"> &lt;morcos&gt;</span> what..  is that an announcement? a question?
<a name="l-103"></a><span class="tm">19:20:17</span><span class="nk"> &lt;morcos&gt;</span> i hate accounts
<a name="l-104"></a><span class="tm">19:20:21</span><span class="nk"> &lt;gmaxwell&gt;</span> For rc1 we can simply say that there are in-flight improvements to that feature link to the PRs. if we really want to... in a reply to the announcement.
<a name="l-105"></a><span class="tm">19:20:42</span><span class="nk"> &lt;sipa&gt;</span> let's just review the outstanding patches, they are tiny
<a name="l-106"></a><span class="tm">19:20:42</span><span class="nk"> &lt;instagibbs&gt;</span> morcos, we use "deprecated" in things that are lasting forever in practice, bad joke
<a name="l-107"></a><span class="tm">19:20:50</span><span class="nk"> &lt;jtimon&gt;</span> mhm, why 9619 doesn't go in for 0.14?
<a name="l-108"></a><span class="tm">19:20:51</span><span class="nk"> &lt;morcos&gt;</span> oh.. yeah
<a name="l-109"></a><span class="tm">19:20:58</span><span class="nk"> &lt;sipa&gt;</span> with some luck we can get everything merged
<a name="l-110"></a><span class="tm">19:21:14</span><span class="nk"> &lt;sipa&gt;</span> branch and rc1 tomorrow
<a name="l-111"></a><span class="tm">19:21:15</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> yes, that there is still work in progress, that's better and more clear than the word experimental
<a name="l-112"></a><span class="tm">19:21:21</span><span class="nk"> &lt;sipa&gt;</span> with whatever is in
<a name="l-113"></a><span class="tm">19:21:33</span><span class="nk"> &lt;morcos&gt;</span> ok, so can we just pick a time.  wumpus is going to call rc1 tomorrow morning..  it tonight we can convince people to merge a few of these other things... that'll leave less for rc2
<a name="l-114"></a><span class="tm">19:22:05</span><span class="nk"> &lt;morcos&gt;</span> that was "if tonight"  , if not , then ok
<a name="l-115"></a><span class="tm">19:22:09</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">wumpus:</span> is that fine by you?
<a name="l-116"></a><span class="tm">19:22:16</span><span class="nk"> &lt;wumpus&gt;</span> yes, that's fine with me
<a name="l-117"></a><span class="tm">19:22:48</span><span class="nk"> &lt;wumpus&gt;</span> I'm okay with another day, let's just not let it slip another week, that next thursday we're again wondering when to do the rc1 :)
<a name="l-118"></a><span class="tm">19:23:15</span><span class="nk"> &lt;sipa&gt;</span> next thursday we should be talking about doing rc2
<a name="l-119"></a><span class="tm">19:23:22</span><span class="nk"> &lt;wumpus&gt;</span> yes, ideally
<a name="l-120"></a><span class="tm">19:23:30</span><span class="nk"> &lt;gmaxwell&gt;</span> We're at a point where beyond the couple in flight PRs little to no more improvement is happening, which is when we need more input.
<a name="l-121"></a><span class="tm">19:23:54</span><span class="nk"> &lt;achow101&gt;</span> so rc1 tomorrow regardless of whether those three prs get merged?
<a name="l-122"></a><span class="tm">19:24:06</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">achow101:</span> that's what i suggest, yes
<a name="l-123"></a><span class="tm">19:24:12</span><span class="nk"> &lt;paveljanik&gt;</span> +1
<a name="l-124"></a><span class="tm">19:24:20</span><span class="nk"> &lt;achow101&gt;</span> ^
<a name="l-125"></a><span class="tm">19:26:14</span><span class="nk"> &lt;sipa&gt;</span> are we ok with talking about things beyond 0.14?
<a name="l-126"></a><span class="tm">19:26:30</span><span class="nk"> &lt;wumpus&gt;</span> sure!
<a name="l-127"></a><span class="tm">19:26:34</span><span class="nk"> &lt;luke-jr&gt;</span> new #topic?
<a name="l-128"></a><span class="tm">19:26:41</span><span class="nk"> &lt;sipa&gt;</span> i'd briefly like to talk about randomness
<a name="l-129"></a><span class="tm">19:26:54</span><span class="nk"> &lt;wumpus&gt;</span> <span class="topic">#topic </span><span class="topicline">randomness</span>
<a name="l-130"></a><span class="tm">19:26:56</span><span class="nk"> &lt;luke-jr&gt;</span> that's random.
<a name="l-131"></a><span class="tm">19:27:06</span><span class="nk"> &lt;sipa&gt;</span> we currently have 3 "levels" of randomnesz
<a name="l-132"></a><span class="tm">19:27:21</span><span class="nk"> &lt;sipa&gt;</span> fastrandomcontext, getrandbytes, getsecurerandbytes
<a name="l-133"></a><span class="tm">19:27:28</span><span class="nk"> &lt;sipa&gt;</span> i'd like to have only 2
<a name="l-134"></a><span class="tm">19:27:30</span><span class="nk"> &lt;wumpus&gt;</span> we need a random number of levels of randomness
<a name="l-135"></a><span class="tm">19:27:42</span><span class="nk"> &lt;wumpus&gt;</span> yes.
<a name="l-136"></a><span class="tm">19:27:46</span><span class="nk"> &lt;wumpus&gt;</span> why are there three?
<a name="l-137"></a><span class="tm">19:27:49</span><span class="nk"> &lt;instagibbs&gt;</span> can you explain "getsecurerandbytes"
<a name="l-138"></a><span class="tm">19:27:58</span><span class="nk"> &lt;instagibbs&gt;</span> im going through code now but..
<a name="l-139"></a><span class="tm">19:27:59</span><span class="nk"> &lt;wumpus&gt;</span> I mean we need one for wallet keys, I understand that
<a name="l-140"></a><span class="tm">19:28:02</span><span class="nk"> &lt;sipa&gt;</span> the last one is used for privaye keys
<a name="l-141"></a><span class="tm">19:28:04</span><span class="nk"> &lt;jtimon&gt;</span> why 9619 doesn't go in for 0.14?
<a name="l-142"></a><span class="tm">19:28:22</span><span class="nk"> &lt;jonasschnelli&gt;</span> <span class="hi">jtimon:</span> wrong topic
<a name="l-143"></a><span class="tm">19:28:27</span><span class="nk"> &lt;sipa&gt;</span> it's as secure as getrandbytes if all goes well, but it's more paranoid
<a name="l-144"></a><span class="tm">19:28:47</span><span class="nk"> &lt;sipa&gt;</span> so, i've been playing with a chacha2p based rng instead of fastrandomcontext
<a name="l-145"></a><span class="tm">19:28:51</span><span class="nk"> &lt;jtimon&gt;</span> <span class="hi">jonasschnelli:</span> suggested topic then
<a name="l-146"></a><span class="tm">19:28:53</span><span class="nk"> &lt;wumpus&gt;</span> I think I'm fine with an extra paranoid level for wallet keys
<a name="l-147"></a><span class="tm">19:28:56</span><span class="nk"> &lt;sipa&gt;</span> *chacha20
<a name="l-148"></a><span class="tm">19:29:17</span><span class="nk"> &lt;sipa&gt;</span> which takes around 10ns for a 32-bit rand
<a name="l-149"></a><span class="tm">19:29:30</span><span class="nk"> &lt;wumpus&gt;</span> it's much more important to have good randomness there then in almost any other place in computing currently
<a name="l-150"></a><span class="tm">19:29:36</span><span class="nk"> &lt;instagibbs&gt;</span> "GetStrongRandBytes" &lt;--- this it?
<a name="l-151"></a><span class="tm">19:29:48</span><span class="nk"> &lt;rabidus&gt;</span> return 4
<a name="l-152"></a><span class="tm">19:29:49</span><span class="nk"> &lt;sipa&gt;</span> the current fastrandomcontext takes 1.5ns, but with extra optimizations it can be made comparablr
<a name="l-153"></a><span class="tm">19:30:08</span><span class="nk"> &lt;sipa&gt;</span> and if we have that, i think we can use strong randomnes for everything
<a name="l-154"></a><span class="tm">19:30:13</span><span class="nk"> &lt;wumpus&gt;</span> for non wallet keys we can probably do with one level
<a name="l-155"></a><span class="tm">19:30:19</span><span class="nk"> &lt;wumpus&gt;</span> is that your plan sipa?
<a name="l-156"></a><span class="tm">19:30:36</span><span class="nk"> &lt;sipa&gt;</span> basically i suggest making all RNGs cryptographic
<a name="l-157"></a><span class="tm">19:30:55</span><span class="nk"> &lt;sipa&gt;</span> but the fast one is not thread-safe, doesn't reseed, doesn't protect against VM reloads
<a name="l-158"></a><span class="tm">19:30:55</span><span class="nk"> &lt;wumpus&gt;</span> so merge the fastrandomcontext and somewhatmoresecure level, and keeping that and the ultra-paranoid one for wallet keys
<a name="l-159"></a><span class="tm">19:31:36</span><span class="nk"> &lt;sipa&gt;</span> i realize the "only two randomness levels" is a bit of an abstract goal
<a name="l-160"></a><span class="tm">19:31:45</span><span class="nk"> &lt;wumpus&gt;</span> yes the fastrandomcontext is supposed to only eb used from one thread at a time
<a name="l-161"></a><span class="tm">19:31:54</span><span class="nk"> &lt;morcos&gt;</span> are there any inner loops that use random numbers?
<a name="l-162"></a><span class="tm">19:31:58</span><span class="nk"> &lt;petertodd&gt;</span> <span class="hi">wumpus:</span> the ultra paranoid one can also use the chacha code
<a name="l-163"></a><span class="tm">19:31:59</span><span class="nk"> &lt;wumpus&gt;</span> because it's for inner loops
<a name="l-164"></a><span class="tm">19:32:05</span><span class="nk"> &lt;sipa&gt;</span> yes, the wallet coin selection
<a name="l-165"></a><span class="tm">19:32:20</span><span class="nk"> &lt;sipa&gt;</span> i benchmarked it, making it chacha20 doesn't affect its performance
<a name="l-166"></a><span class="tm">19:32:23</span><span class="nk"> &lt;wumpus&gt;</span> any locking for synchronization there would be pretty bad
<a name="l-167"></a><span class="tm">19:32:41</span><span class="nk"> &lt;wumpus&gt;</span> there's also an inner random loop in the address selection code IIRC
<a name="l-168"></a><span class="tm">19:32:56</span><span class="nk"> &lt;jonasschnelli&gt;</span> Do we need cPRNG for coin selection?
<a name="l-169"></a><span class="tm">19:32:56</span><span class="nk"> &lt;sipa&gt;</span> yup
<a name="l-170"></a><span class="tm">19:33:02</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">sipa:</span> yes chacha20 is fast, but the problem is the thread safety
<a name="l-171"></a><span class="tm">19:33:05</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">jonasschnelli:</span> no, we don't
<a name="l-172"></a><span class="tm">19:33:14</span><span class="nk"> &lt;gmaxwell&gt;</span> sipa wants to reduce the codebase complexity.
<a name="l-173"></a><span class="tm">19:33:19</span><span class="nk"> &lt;sipa&gt;</span> but chacha20 is so fast i don't care
<a name="l-174"></a><span class="tm">19:33:21</span><span class="nk"> &lt;wumpus&gt;</span> if you want to be able to share a random context between threads, you end up with lots of synchronization overhead
<a name="l-175"></a><span class="tm">19:33:23</span><span class="nk"> &lt;jonasschnelli&gt;</span> Yes. This would be good.
<a name="l-176"></a><span class="tm">19:33:51</span><span class="nk"> &lt;wumpus&gt;</span> that's why the inner loops use a non-threadsafe random context, =which doesn't matter as it's only used by one thread
<a name="l-177"></a><span class="tm">19:34:01</span><span class="nk"> &lt;bitcoin-git&gt;</span> [13bitcoin] 15gmaxwell opened pull request #9779: Update nMinimumChainWork and defaultAssumeValid. (06master...06update_chainparams) 02https://github.com/bitcoin/bitcoin/pull/9779
<a name="l-178"></a><span class="tm">19:34:11</span><span class="nk"> &lt;sipa&gt;</span> having clearer expectations about the rngs may simplify getting rid of openssl later
<a name="l-179"></a><span class="tm">19:34:18</span><span class="nk"> &lt;wumpus&gt;</span> the thread sync overhead is where the overhead would be
<a name="l-180"></a><span class="tm">19:34:24</span><span class="nk"> &lt;sipa&gt;</span> though that's not something to discuss now, i think
<a name="l-181"></a><span class="tm">19:34:38</span><span class="nk"> &lt;wumpus&gt;</span> so how would you cope with that sipa? or would it all be non-shared context?
<a name="l-182"></a><span class="tm">19:35:07</span><span class="nk"> &lt;sipa&gt;</span> so 1) replace fastrandomcontext with a bit more featureful chacha20 based one
<a name="l-183"></a><span class="tm">19:35:39</span><span class="nk"> &lt;wumpus&gt;</span> yes, depending on openssl for just randomness is fine, there's no urgent reason to get rid of that, and it seems controversial for some people
<a name="l-184"></a><span class="tm">19:35:47</span><span class="nk"> &lt;sipa&gt;</span> 2) see where the current non-strong-getrandbytes can be replaced with fastrandcontexts, and replace everything with getstrongranbytes
<a name="l-185"></a><span class="tm">19:35:50</span><span class="nk"> &lt;wumpus&gt;</span> that makes sense
<a name="l-186"></a><span class="tm">19:36:06</span><span class="nk"> &lt;gmaxwell&gt;</span> one of the harder points (beyond threading) is that we need to manage which RNGs are robust against a VM image being snapshotted and restored.  Coinselection using the same randomness again after a VM restore would be harmless.  Choosing a crypto nonce would be much less harmless.  If a RNG needs to be outputing data intially after restore there is unfortunately a runtime cost (esp on ARM).
<a name="l-187"></a><span class="tm">19:36:58</span><span class="nk"> &lt;wumpus&gt;</span> also I think we need an abstraction for 'kernel randomness', this came up recently in context of OpenBSD, which doesn't have /dev/random/urandom available in all contexts
<a name="l-188"></a><span class="tm">19:37:07</span><span class="nk"> &lt;gmaxwell&gt;</span> Pieter and I have been debating this a little bit the past could days.
<a name="l-189"></a><span class="tm">19:37:23</span><span class="nk"> &lt;wumpus&gt;</span> the modern way,sandbox-proof way seems to be to use a specific system call fo that, but it differs per OS unfortunately
<a name="l-190"></a><span class="tm">19:37:27</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">wumpus:</span> yup, that would go into the (singular) getstrongrandbytes implementation
<a name="l-191"></a><span class="tm">19:37:27</span><span class="nk"> &lt;cfields&gt;</span> isn't there an old PR for exactly that abstraction?
<a name="l-192"></a><span class="tm">19:37:28</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">wumpus:</span> we do have a function for OS randomness, it should be smarter of course... but it was only fairly recently introduced.
<a name="l-193"></a><span class="tm">19:37:48</span><span class="nk"> &lt;Victorsueca&gt;</span> maybe you could get rid of getrandbytes? so we keep the fast one for simple operations and the secure and paranoid one for important stuff and you can focus on implementing more features on those two
<a name="l-194"></a><span class="tm">19:37:59</span><span class="nk"> &lt;gmaxwell&gt;</span> GetOSRand()
<a name="l-195"></a><span class="tm">19:38:06</span><span class="nk"> &lt;wumpus&gt;</span> (linux also has a "getrandom" system call that can be used instead of /dev/urandom, in sandboxes)
<a name="l-196"></a><span class="tm">19:38:13</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">Victorsueca:</span> read the above discussion, that is exactly what i am proposing
<a name="l-197"></a><span class="tm">19:38:22</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> ok
<a name="l-198"></a><span class="tm">19:38:41</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">wumpus:</span> yes, in newer systems. We do mention using that in the PR that implemented GetOSRand I think. (getentropy)
<a name="l-199"></a><span class="tm">19:38:43</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> in any case, that is the lowerst level, it shouldn't be regarded as 'a level of randomness'
<a name="l-200"></a><span class="tm">19:38:52</span><span class="nk"> &lt;gmaxwell&gt;</span> so I think we know what we need to go there.
<a name="l-201"></a><span class="tm">19:39:09</span><span class="nk"> &lt;wumpus&gt;</span> indeed, getentropy is bsd, getrandom is linux
<a name="l-202"></a><span class="tm">19:39:29</span><span class="nk"> &lt;Victorsueca&gt;</span> <span class="hi">sipa:</span> ohh, I somehow misread that you where proposing to merge the fast and the middle one to make it simpler
<a name="l-203"></a><span class="tm">19:39:37</span><span class="nk"> &lt;sipa&gt;</span> FWIW linux 4.8 also switched to chacha20 for /dev/urandom
<a name="l-204"></a><span class="tm">19:39:48</span><span class="nk"> &lt;wumpus&gt;</span> yes
<a name="l-205"></a><span class="tm">19:40:14</span><span class="nk"> &lt;gmaxwell&gt;</span> The framework I think about this is that we have several randomized algorithims where there are basically no cryptographic guarentees needed... coin selection, addr man buckets, and tests being some examples.  These need to be fast but can all use just a local context, need no resistance against reversal (somsone steals your ram and recovers older randomness) or prediction (vm saves repeat rando
<a name="l-206"></a><span class="tm">19:40:19</span><span class="nk"> &lt;petertodd&gt;</span> <span class="hi">gmaxwell:</span> re: VM image being snapshotted and restored, that's basically a case where reusing a secret is by itself harmful - is there an example in Bitcoin where that's the case, now that we do deterministic signing?
<a name="l-207"></a><span class="tm">19:40:20</span><span class="nk"> &lt;gmaxwell&gt;</span> mness).
<a name="l-208"></a><span class="tm">19:40:22</span><span class="nk"> &lt;gmaxwell&gt;</span> So thats one set of uses.
<a name="l-209"></a><span class="tm">19:40:23</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">Victorsueca:</span> i'm proposing to make the fast one stronger (but not much slower), and then things using the middle one need to be judged on a case by case basis whether they can use the new fast one, or the strong one
<a name="l-210"></a><span class="tm">19:40:50</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">Victorsueca:</span> after that, the middle one goes away
<a name="l-211"></a><span class="tm">19:40:59</span><span class="nk"> &lt;gmaxwell&gt;</span> Then we have other uses where we have randomized behavior which does have stronger security requirements, like ping nonces which need to be strongly unforgable to prevent peers hiding their latency.
<a name="l-212"></a><span class="tm">19:41:07</span><span class="nk"> &lt;Victorsueca&gt;</span> <span class="hi">sipa:</span> makes sense
<a name="l-213"></a><span class="tm">19:41:11</span><span class="nk"> &lt;gmaxwell&gt;</span> But even if they're broken it just turns into DOS attacks.
<a name="l-214"></a><span class="tm">19:41:39</span><span class="nk"> &lt;wumpus&gt;</span> it's strong, but far from as strong a requirement as wallet keys
<a name="l-215"></a><span class="tm">19:41:43</span><span class="nk"> &lt;gmaxwell&gt;</span> Then we have things like long term keys which we do infrequently and basically no cost is too high. And they have to meet basically every security characteristic we can imagine.
<a name="l-216"></a><span class="tm">19:41:57</span><span class="nk"> &lt;wumpus&gt;</span> indeed
<a name="l-217"></a><span class="tm">19:42:05</span><span class="nk"> &lt;cfields&gt;</span> suggested similar next topic: clocks
<a name="l-218"></a><span class="tm">19:42:09</span><span class="nk"> &lt;gmaxwell&gt;</span> the second class often has to be moderately fast too.
<a name="l-219"></a><span class="tm">19:42:41</span><span class="nk"> &lt;gmaxwell&gt;</span> Pieter would like to collapse this class hierarchy some by making the first class use the second while making the second fast enough that it's fine to do so.
<a name="l-220"></a><span class="tm">19:43:09</span><span class="nk"> &lt;Victorsueca&gt;</span> <span class="hi">cfields:</span> clocks as in CPU clock or as in timestamp?
<a name="l-221"></a><span class="tm">19:43:27</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">Victorsueca:</span> please wait until the topic is actaully started
<a name="l-222"></a><span class="tm">19:43:33</span><span class="nk"> &lt;Victorsueca&gt;</span> ohh, sorry
<a name="l-223"></a><span class="tm">19:43:48</span><span class="nk"> &lt;wumpus&gt;</span> though I think we've wrapped up randomness
<a name="l-224"></a><span class="tm">19:43:51</span><span class="nk"> &lt;sipa&gt;</span> agree
<a name="l-225"></a><span class="tm">19:43:56</span><span class="nk"> &lt;wumpus&gt;</span> <span class="topic">#topic </span><span class="topicline">clocks</span>
<a name="l-226"></a><span class="tm">19:43:58</span><span class="nk"> &lt;gmaxwell&gt;</span> I have a little doubt that this is possible, because I think the second may need to deal with reversal resistace and prediction resistance, which cannot be done for free. (e.g. you must mix in TSC and/or RDRAND at every use.)
<a name="l-227"></a><span class="tm">19:43:59</span><span class="nk"> &lt;instagibbs&gt;</span> he has to gavel before we can switch
<a name="l-228"></a><span class="tm">19:44:02</span><span class="nk"> &lt;gmaxwell&gt;</span> okay!
<a name="l-229"></a><span class="tm">19:44:16</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> oh, didn't know you were still typing, sorry
<a name="l-230"></a><span class="tm">19:44:18</span><span class="nk"> &lt;cfields&gt;</span> I have some local changes that implement the concept of different clocks/time_points/durations. The objective is for them to be incompatible with each-other.
<a name="l-231"></a><span class="tm">19:44:27</span><span class="nk"> &lt;gmaxwell&gt;</span> thats fine! just some things to think about.
<a name="l-232"></a><span class="tm">19:44:33</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">cfields:</span> yes, that seems the way to go about it
<a name="l-233"></a><span class="tm">19:44:54</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">cfields:</span> f i may interject... i was thinking about creating a generic int class wrapper that supports no implicit conversioms
<a name="l-234"></a><span class="tm">19:44:59</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">cfields:</span> pieter and I were talking about type safty recently, and pieter suggested a scheme for introducing more integer types which will never implicitly be converted.
<a name="l-235"></a><span class="tm">19:45:19</span><span class="nk"> &lt;wumpus&gt;</span> most importantly we should start using monotonic timestamps in the network code where possible
<a name="l-236"></a><span class="tm">19:45:51</span><span class="nk"> &lt;cfields&gt;</span> that sounds fine, but i'm not sure that they're entirely related here. The (my) objective is to stop storing time as an int, and instead as a time_value
<a name="l-237"></a><span class="tm">19:46:01</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">cfields:</span> or are timestamps in a c++11 world not something that fit in integers?
<a name="l-238"></a><span class="tm">19:46:04</span><span class="nk"> &lt;cfields&gt;</span> that way it can be represented in sec/msec/whatever whenever it's needed
<a name="l-239"></a><span class="tm">19:46:10</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">sipa:</span> exactly
<a name="l-240"></a><span class="tm">19:46:23</span><span class="nk"> &lt;cfields&gt;</span> it also enforces timestamps that can't be used on the wrong clock
<a name="l-241"></a><span class="tm">19:46:32</span><span class="nk"> &lt;sipa&gt;</span> i'm confused
<a name="l-242"></a><span class="tm">19:46:37</span><span class="nk"> &lt;gmaxwell&gt;</span> I have suggested in the past that we consider constructing a monotonic local clock, but wumpus seemed to not like the idea. which I think is orthorgonal to the type safty thing, but it would perhaps make time more sane in the codebase.
<a name="l-243"></a><span class="tm">19:46:44</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">cfields:</span> in general that sounds good, though in some structures such as the block index we want to use as compact types as possible
<a name="l-244"></a><span class="tm">19:47:02</span><span class="nk"> &lt;gmaxwell&gt;</span> saftey*
<a name="l-245"></a><span class="tm">19:47:09</span><span class="nk"> &lt;gmaxwell&gt;</span> doh
<a name="l-246"></a><span class="tm">19:47:12</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">wumpus:</span> sure, you can always get an int out of it if you want
<a name="l-247"></a><span class="tm">19:47:13</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> huh I'm all for using monotonic clocks were possible, they're just not good for everything
<a name="l-248"></a><span class="tm">19:47:22</span><span class="nk"> &lt;gmaxwell&gt;</span> safety**
<a name="l-249"></a><span class="tm">19:47:48</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">cfields:</span> my point was to have a template&lt;typename tag&gt; class non_convertible_int
<a name="l-250"></a><span class="tm">19:47:52</span><span class="nk"> &lt;cfields&gt;</span> also, i believe the class is actually not bigger than an int. It's just not convertable to int
<a name="l-251"></a><span class="tm">19:48:21</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">cfields:</span> well if it represents micro/nanosecond it needs to be at least uint64 :)
<a name="l-252"></a><span class="tm">19:48:23</span><span class="nk"> &lt;sipa&gt;</span> and then have typedef non_comvertible_int&lt;systemtime&gt; systemtime_type
<a name="l-253"></a><span class="tm">19:48:36</span><span class="nk"> &lt;sipa&gt;</span> and systemtype_type is what is used
<a name="l-254"></a><span class="tm">19:48:44</span><span class="nk"> &lt;gmaxwell&gt;</span> you would get_int() on the object to get an int. You would just get a conversion by surprise.
<a name="l-255"></a><span class="tm">19:48:45</span><span class="nk"> &lt;sipa&gt;</span> *systemtime_type
<a name="l-256"></a><span class="tm">19:48:54</span><span class="nk"> &lt;gmaxwell&gt;</span> I would _hope_ we can construct something that at runtime is _exactly_ equal to using an integer.
<a name="l-257"></a><span class="tm">19:49:06</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">cfields:</span> you're being inconsistent
<a name="l-258"></a><span class="tm">19:49:19</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">sipa:</span> http://en.cppreference.com/w/cpp/chrono/time_point
<a name="l-259"></a><span class="tm">19:49:42</span><span class="nk"> &lt;gmaxwell&gt;</span> I think we should do this far more broadly than just timestamps however.
<a name="l-260"></a><span class="tm">19:49:43</span><span class="nk"> &lt;sipa&gt;</span> we can't use that in blocks, etc
<a name="l-261"></a><span class="tm">19:50:08</span><span class="nk"> &lt;wumpus&gt;</span> indeed - block times /consensus are a special case
<a name="l-262"></a><span class="tm">19:50:25</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">sipa:</span> we don't use timeval in blocks either though, we convert from the clock
<a name="l-263"></a><span class="tm">19:50:26</span><span class="nk"> &lt;sipa&gt;</span> but perhaps we should use those types in network state, measuring speed, ...
<a name="l-264"></a><span class="tm">19:50:35</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">sipa:</span> i'll demonstrate with code, probably easier that way
<a name="l-265"></a><span class="tm">19:50:53</span><span class="nk"> &lt;wumpus&gt;</span> right
<a name="l-266"></a><span class="tm">19:51:13</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">cfields:</span> what i want to address is the fact that an int or int64 can now mean microseconds, milliseconds, or seconds, and either system time, or monotonous time, or network-adjusted timr
<a name="l-267"></a><span class="tm">19:51:44</span><span class="nk"> &lt;sipa&gt;</span> it's fine that those are int-like, but they shouldn't be convertible from one into another
<a name="l-268"></a><span class="tm">19:51:59</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">sipa:</span> and that's exactly what i've addressed. Each of those gets its own type, and they're not convertable to eachother. But you can do a duration_cast&lt;std::chrono::seconds&gt;(foo) and get an int64_t seconds value out
<a name="l-269"></a><span class="tm">19:52:09</span><span class="nk"> &lt;sipa&gt;</span> anyway, for everything but consensus data structures, perhaps there are more c++ish ways
<a name="l-270"></a><span class="tm">19:52:50</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">cfields:</span> let's discuss this outside of theeeting
<a name="l-271"></a><span class="tm">19:52:51</span><span class="nk"> &lt;gmaxwell&gt;</span> This problem exists far beyond timestamps however. Use a node ID as a tx count? no problem.  Use a vin index as a block number? no problem. Use a bytes sent as a relay bool? no problem.
<a name="l-272"></a><span class="tm">19:53:16</span><span class="nk"> &lt;gmaxwell&gt;</span> We have multiple times had potentially serious bugs from the general issue of implicit conversions.
<a name="l-273"></a><span class="tm">19:53:35</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">gmaxwell:</span> yes, agreed that the tag would be very useful
<a name="l-274"></a><span class="tm">19:53:42</span><span class="nk"> &lt;gmaxwell&gt;</span> (or in the case of sighash single, an actual consensus behavior flaw)
<a name="l-275"></a><span class="tm">19:53:50</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">sipa:</span> np
<a name="l-276"></a><span class="tm">19:53:51</span><span class="nk"> &lt;sipa&gt;</span> jtimon had a topic as well
<a name="l-277"></a><span class="tm">19:53:56</span><span class="nk"> &lt;wumpus&gt;</span> using enumerations instead of booleans would also go a long way
<a name="l-278"></a><span class="tm">19:54:00</span><span class="nk"> &lt;jtimon&gt;</span> well, just a question really
<a name="l-279"></a><span class="tm">19:54:03</span><span class="nk"> &lt;jonasschnelli&gt;</span> I also have a little proposal
<a name="l-280"></a><span class="tm">19:54:04</span><span class="nk"> &lt;gmaxwell&gt;</span> all the data is there in the compile to prevent these mistakes, we're just not exposing it right. :)
<a name="l-281"></a><span class="tm">19:54:13</span><span class="nk"> &lt;jtimon&gt;</span> I guess it can wait after the meeting
<a name="l-282"></a><span class="tm">19:54:16</span><span class="nk"> &lt;wumpus&gt;</span> especially for functions that have tons of boolean arguments in succession, that's just crazy
<a name="l-283"></a><span class="tm">19:54:17</span><span class="nk"> &lt;sipa&gt;</span> <span class="hi">wumpus:</span> yeah, generally useful
<a name="l-284"></a><span class="tm">19:54:26</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">wumpus:</span> yea, using bools, also using structs to get named parameters... lots of things we can do.
<a name="l-285"></a><span class="tm">19:54:30</span><span class="nk"> &lt;cfields&gt;</span> <span class="hi">wumpus:</span> for sure
<a name="l-286"></a><span class="tm">19:54:43</span><span class="nk"> &lt;jtimon&gt;</span> or answered fast enough that it doesn't need its own topic: "why 9619 doesn't go in for 0.14?"
<a name="l-287"></a><span class="tm">19:54:48</span><span class="nk"> &lt;gmaxwell&gt;</span> true false true true false die die die.  ... I hate counting aruments when changing things.
<a name="l-288"></a><span class="tm">19:54:48</span><span class="nk"> &lt;morcos&gt;</span> <span class="hi">jtimon:</span> i think because there was an error reported and no explanation that it was fixed or wasn't really a problem.  that's at least why i haven't looked at the PR.
<a name="l-289"></a><span class="tm">19:54:53</span><span class="nk"> &lt;wumpus&gt;</span> (well with some IDEs you can see what gets assigned to what parameter because it parses the interface, but that's not something you can realy on that everyone has available)
<a name="l-290"></a><span class="tm">19:55:00</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> exactly
<a name="l-291"></a><span class="tm">19:55:08</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">jtimon:</span> what was your topic?
<a name="l-292"></a><span class="tm">19:55:09</span><span class="nk"> &lt;instagibbs&gt;</span> gmaxwell, the fun really starts when you drop an arg with a default value at the end
<a name="l-293"></a><span class="tm">19:55:21</span><span class="nk"> &lt;cfields&gt;</span> (or three)
<a name="l-294"></a><span class="tm">19:55:28</span><span class="nk"> &lt;jtimon&gt;</span> <span class="hi">morcos:</span> that explains why is not merged, not why it's not labeled 0.14, but ok I guess
<a name="l-295"></a><span class="tm">19:55:53</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">jtimon:</span> let's reverse the question: why would it need to be added for 0.14?
<a name="l-296"></a><span class="tm">19:55:55</span><span class="nk"> &lt;jtimon&gt;</span> <span class="hi">wumpus:</span> including 9619 in 0.14
<a name="l-297"></a><span class="tm">19:56:11</span><span class="nk"> &lt;jtimon&gt;</span> it's a bugfix and is simple enough, why not?
<a name="l-298"></a><span class="tm">19:56:41</span><span class="nk"> &lt;sipa&gt;</span> i think it can go in, it's trivial and very small in scope
<a name="l-299"></a><span class="tm">19:56:45</span><span class="nk"> &lt;gmaxwell&gt;</span> basically without it a plausable downstream gbt user that changes the transaction set could construct an overlarge block, is that the concern there?
<a name="l-300"></a><span class="tm">19:56:46</span><span class="nk"> &lt;wumpus&gt;</span> I'm fine with merging it before 0.14, if its sufficiently reviewed and teste
<a name="l-301"></a><span class="tm">19:56:50</span><span class="nk"> &lt;wumpus&gt;</span> it will however not hold up rc1
<a name="l-302"></a><span class="tm">19:57:08</span><span class="nk"> &lt;gmaxwell&gt;</span> it looks trivial and small in scope, and if my understanding is correct it should go in.. but sure, nothing should hold up rc1.
<a name="l-303"></a><span class="tm">19:57:19</span><span class="nk"> &lt;gmaxwell&gt;</span> at least nothing that we know of now.
<a name="l-304"></a><span class="tm">19:57:20</span><span class="nk"> &lt;sipa&gt;</span> fair
<a name="l-305"></a><span class="tm">19:57:35</span><span class="nk"> &lt;jonasschnelli&gt;</span> Not sure if this makes sense, But I propose to rename the ./qa dir to ./test (or something that sorts after ./src). I think it would be better to have the RPC tests further down in the PRs diff.
<a name="l-306"></a><span class="tm">19:57:36</span><span class="nk"> &lt;jtimon&gt;</span> sure, was simply surprised it didn't had the 0.14 label since it's not really that new
<a name="l-307"></a><span class="tm">19:57:57</span><span class="nk"> &lt;Victorsueca&gt;</span> I see lots of utACKs but not any ACK, so trivial it doesn't need testing I assume?
<a name="l-308"></a><span class="tm">19:57:57</span><span class="nk"> &lt;gmaxwell&gt;</span> short of some kind of crash eat money doom bug showing up before we manage to get it out (and even that shouldn't delay _constructing_ RC1; if doom shows up we can abort launch)
<a name="l-309"></a><span class="tm">19:58:30</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> sure, there are always serious enough problems possible that should postpone the release
<a name="l-310"></a><span class="tm">19:58:57</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">jonasschnelli:</span> On that I'd like to get into a state where make check is running those tests. They are most of our tests now, and the most valuable.. and really people building with compilers we've never seen before _REALLY_ ought to be running them.
<a name="l-311"></a><span class="tm">19:59:18</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">jonasschnelli:</span> don't really have an opinion on that, does it matter much how things are sorted?
<a name="l-312"></a><span class="tm">19:59:35</span><span class="nk"> &lt;gmaxwell&gt;</span> Why would the sorting matter?
<a name="l-313"></a><span class="tm">19:59:39</span><span class="nk"> &lt;jonasschnelli&gt;</span> As long as review is a bottleneck I think it matters
<a name="l-314"></a><span class="tm">19:59:53</span><span class="nk"> &lt;jonasschnelli&gt;</span> But maybe I'm alone with that opinion.
<a name="l-315"></a><span class="tm">20:00:05</span><span class="nk"> &lt;gmaxwell&gt;</span> OH so they show up lower on github.
<a name="l-316"></a><span class="tm">20:00:21</span><span class="nk"> &lt;sipa&gt;</span> /zzztest
<a name="l-317"></a><span class="tm">20:00:28</span><span class="nk"> &lt;wumpus&gt;</span> my biggest pet peeve is that they're called RPC tests, not 'functional tests' or such, they're testing much more than RPC these days :)
<a name="l-318"></a><span class="tm">20:00:41</span><span class="nk"> &lt;jonasschnelli&gt;</span> ./test_functional
<a name="l-319"></a><span class="tm">20:00:43</span><span class="nk"> &lt;gmaxwell&gt;</span> It is sometimes a bit confusing that the tests show up first... otoh it can be informative to read the test before the change in the cases where the test is especially good. :)
<a name="l-320"></a><span class="tm">20:00:45</span><span class="nk"> &lt;wumpus&gt;</span> but not serious enough to actually go on renamind directories
<a name="l-321"></a><span class="tm">20:00:49</span><span class="nk"> &lt;sipa&gt;</span> also, pull-tester should be merged in rpc-tests
<a name="l-322"></a><span class="tm">20:00:51</span><span class="nk"> &lt;gmaxwell&gt;</span> <span class="hi">wumpus:</span> they are "system tests"  rpc is incidental.
<a name="l-323"></a><span class="tm">20:01:36</span><span class="nk"> &lt;sipa&gt;</span> we don't have pulltester anymore, and it's annoying to always change directory :)
<a name="l-324"></a><span class="tm">20:01:44</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">gmaxwell:</span> yes, it doesn't matter what interface they use, whether it's RPC or P2P or ZMQ or REST or command line arguments etc
<a name="l-325"></a><span class="tm">20:01:44</span><span class="nk"> &lt;instagibbs&gt;</span> we're over time
<a name="l-326"></a><span class="tm">20:01:46</span><span class="nk"> &lt;instagibbs&gt;</span> btw
<a name="l-327"></a><span class="tm">20:01:52</span><span class="nk"> &lt;jonasschnelli&gt;</span> Okay. I'll do a cleanup PR once we branch off.
<a name="l-328"></a><span class="tm">20:01:53</span><span class="nk"> &lt;wumpus&gt;</span> <span class="hi">instagibbs:</span> ah yes
<a name="l-329"></a><span class="tm">20:01:55</span><span class="nk"> &lt;wumpus&gt;</span> <span class="cmd">#endmeeting</span><span class="cmdline"></span></pre>
</body></html>
